"""SQLAlchemy ORM models for NanoClaw database.

Maps to the schema defined in alembic/versions/001_initial_schema.py.
These models represent the 6 core tables of the NanoClaw database.
"""

from __future__ import annotations

from sqlalchemy import (
    ForeignKey,
    Index,
    Integer,
    Text,
    UniqueConstraint,
    create_engine,
)
from sqlalchemy.engine import Engine
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


class Base(DeclarativeBase):
    """Declarative base class for all NanoClaw ORM models."""


class Chat(Base):
    """A WhatsApp chat tracked by NanoClaw.

    Stores metadata for all chats (not just registered groups) to enable
    group discovery without storing sensitive message content.

    Attributes:
        jid: WhatsApp JID (primary key).
        name: Display name of the chat or group.
        last_message_time: ISO timestamp of most recent message.
    """

    __tablename__ = "chats"

    jid: Mapped[str] = mapped_column(Text, primary_key=True)
    name: Mapped[str | None] = mapped_column(Text, nullable=True)
    last_message_time: Mapped[str | None] = mapped_column(Text, nullable=True)


class Message(Base):
    """A message stored for a registered group.

    Only messages from registered groups are stored (for context history).
    Uses composite primary key (id, chat_jid) to match the TypeScript schema.

    Attributes:
        id: WhatsApp message ID.
        chat_jid: JID of the group this message belongs to.
        sender: JID of the sender.
        sender_name: Display name of the sender.
        content: Text content of the message.
        timestamp: ISO timestamp string.
        is_from_me: 1 if sent by the bot's number, 0 otherwise.
        is_bot_message: 1 if generated by the bot agent, 0 otherwise.
    """

    __tablename__ = "messages"
    __table_args__ = (Index("idx_timestamp", "timestamp"),)

    id: Mapped[str] = mapped_column(Text, primary_key=True)
    chat_jid: Mapped[str] = mapped_column(Text, ForeignKey("chats.jid"), primary_key=True)
    sender: Mapped[str | None] = mapped_column(Text, nullable=True)
    sender_name: Mapped[str | None] = mapped_column(Text, nullable=True)
    content: Mapped[str | None] = mapped_column(Text, nullable=True)
    timestamp: Mapped[str | None] = mapped_column(Text, nullable=True)
    is_from_me: Mapped[int | None] = mapped_column(Integer, nullable=True)
    is_bot_message: Mapped[int] = mapped_column(Integer, server_default="0")


class ScheduledTask(Base):
    """A user-defined scheduled task.

    Tasks can be cron-based, interval-based, or one-time. Each task runs
    a prompt against the Claude agent in the specified group context.

    Attributes:
        id: Unique task identifier (e.g., 'task-{timestamp}-{random}').
        group_folder: Folder of the owning group under groups/.
        chat_jid: JID to deliver the agent's response to.
        prompt: The prompt text to run.
        schedule_type: One of 'cron', 'interval', 'once'.
        schedule_value: Cron string, milliseconds, or ISO timestamp.
        context_mode: 'isolated' (fresh session) or 'group' (reuse session).
        next_run: ISO timestamp of the next scheduled execution.
        last_run: ISO timestamp of the most recent execution.
        last_result: Summary of the most recent result.
        status: 'active', 'paused', or 'completed'.
        created_at: ISO timestamp when the task was created.
    """

    __tablename__ = "scheduled_tasks"
    __table_args__ = (
        Index("idx_next_run", "next_run"),
        Index("idx_status", "status"),
    )

    id: Mapped[str] = mapped_column(Text, primary_key=True)
    group_folder: Mapped[str] = mapped_column(Text, nullable=False)
    chat_jid: Mapped[str] = mapped_column(Text, nullable=False)
    prompt: Mapped[str] = mapped_column(Text, nullable=False)
    schedule_type: Mapped[str] = mapped_column(Text, nullable=False)
    schedule_value: Mapped[str] = mapped_column(Text, nullable=False)
    context_mode: Mapped[str] = mapped_column(Text, server_default="isolated")
    next_run: Mapped[str | None] = mapped_column(Text, nullable=True)
    last_run: Mapped[str | None] = mapped_column(Text, nullable=True)
    last_result: Mapped[str | None] = mapped_column(Text, nullable=True)
    status: Mapped[str] = mapped_column(Text, server_default="active")
    created_at: Mapped[str] = mapped_column(Text, nullable=False)


class TaskRunLog(Base):
    """An audit log entry for a single scheduled task execution.

    Attributes:
        id: Auto-incremented primary key.
        task_id: FK to scheduled_tasks.id.
        run_at: ISO timestamp when the run started.
        duration_ms: How long the run took in milliseconds.
        status: 'success' or 'error'.
        result: Result text (truncated summary).
        error: Error message if status is 'error'.
    """

    __tablename__ = "task_run_logs"
    __table_args__ = (Index("idx_task_run_logs", "task_id", "run_at"),)

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    task_id: Mapped[str] = mapped_column(Text, ForeignKey("scheduled_tasks.id"), nullable=False)
    run_at: Mapped[str] = mapped_column(Text, nullable=False)
    duration_ms: Mapped[int] = mapped_column(Integer, nullable=False)
    status: Mapped[str] = mapped_column(Text, nullable=False)
    result: Mapped[str | None] = mapped_column(Text, nullable=True)
    error: Mapped[str | None] = mapped_column(Text, nullable=True)


class RouterState(Base):
    """Key-value store for orchestrator state (e.g., last_timestamp).

    Attributes:
        key: State key (primary key).
        value: State value (JSON string for complex values).
    """

    __tablename__ = "router_state"

    key: Mapped[str] = mapped_column(Text, primary_key=True)
    value: Mapped[str] = mapped_column(Text, nullable=False)


class SessionRecord(Base):
    """Persisted Claude session IDs keyed by group folder.

    Allows the orchestrator to resume agent sessions across restarts.

    Attributes:
        group_folder: Folder name of the group (primary key).
        session_id: Claude session ID for this group.
    """

    __tablename__ = "sessions"

    group_folder: Mapped[str] = mapped_column(Text, primary_key=True)
    session_id: Mapped[str] = mapped_column(Text, nullable=False)


class RegisteredGroup(Base):
    """A WhatsApp group registered to receive agent responses.

    Attributes:
        jid: WhatsApp JID (primary key).
        name: Display name of the group.
        folder: Unique filesystem folder name under groups/.
        trigger_pattern: The trigger string (e.g., '@Andy').
        added_at: ISO timestamp when the group was registered.
        container_config: JSON-serialized ContainerConfig or None.
        requires_trigger: 1 if trigger is required, 0 if all messages trigger.
    """

    __tablename__ = "registered_groups"
    __table_args__ = (UniqueConstraint("folder"),)

    jid: Mapped[str] = mapped_column(Text, primary_key=True)
    name: Mapped[str] = mapped_column(Text, nullable=False)
    folder: Mapped[str] = mapped_column(Text, nullable=False, unique=True)
    trigger_pattern: Mapped[str] = mapped_column(Text, nullable=False)
    added_at: Mapped[str] = mapped_column(Text, nullable=False)
    container_config: Mapped[str | None] = mapped_column(Text, nullable=True)
    requires_trigger: Mapped[int] = mapped_column(Integer, server_default="1")


def create_engine_for_path(db_path: str) -> Engine:
    """Create a SQLAlchemy engine for the given SQLite path.

    Args:
        db_path: Path to the SQLite database file. Use ':memory:' for testing.

    Returns:
        SQLAlchemy engine configured for SQLite with WAL journal mode.
    """
    from sqlalchemy import event

    engine = create_engine(f"sqlite:///{db_path}", echo=False)

    @event.listens_for(engine, "connect")
    def set_sqlite_pragma(dbapi_connection: object, _connection_record: object) -> None:
        """Enable WAL mode and foreign keys for each new connection."""
        cursor = dbapi_connection.cursor()  # type: ignore[attr-defined]
        cursor.execute("PRAGMA journal_mode=WAL")
        cursor.execute("PRAGMA foreign_keys=ON")
        cursor.close()

    return engine
